class 클래스명{
   1. 필드: 멤버변수=instance변수
   2. 메소드 : 클래스가 할 수 있는 기능
               void 메소드- 리턴데이터가 없는 메소드  
                리턴데이터가 있는 메소드 - 리턴데이터에 따라 리턴타입이 결정됨 
   3. 생성자 : 클래스의 필드에 데이터를 담기 위해 선언한다.  
}
클래스의 구성요소(멤버)

class Test{
	String subject;
	private int  jumsu;	
	
	
	Test(int jumsu, String subject ){
		this.subject = subject;
		this.jumsu = jumsu;
	}
	Test(String subject, int jumsu ){
		this.subject = subject;
		this.jumsu = jumsu;
	}
	Test(String subject ){
		this.subject = subject;
	}
	
	void reTest(int jumsu){
		this.jumsu = jumsu;
	}
	
	int getJumsu(){
		return jumsu;
	}
}  

클래스 : 객체를 생성하기 위한 틀이면서, 자체가 하나의 데이터타입이 된다.
객체생성: new Test(); -> 생성되어 존재하고 있는 위치(주소)를 알고 있다.
         클래스내에 선언된 구성요소를 메모리에 올려놓게 된다.
파라미터가 없는 생성자가 default생성자
클래스내에 생성자가 선언된 게 없으면 default생성자가 자동으로 생성된다.
객체는 메모리에 올라가 있게 된다 : instance
특성을 지어주는 것: 필드에 데이터를 담는다


Test java = new Test();
java.subject = "자바";
java.jumsu = 90;

생성자 파라미터 변수와 필드명이 동일할때 구분하기 위해서
필드명 앞에  this를 붙인다.
this -> 클래스를 의미한다.
new Test(90, "자바");
Test html = new Test(50, "HTML");
html.reTest(85);

System.out.print( html.jumsu ); 

자바프로그램을 실행하려면 실행의 시작점은 메인메소드
public static void main(String[] s) 메소드

class TestMain{
	public static void main(String[] s){
	
		new Test(90, "자바");
		Test html = new Test(50, "HTML");
		html.reTest(85);
		
		jumsu 가 private 으로 선언되면 접근불가 
		System.out.print( html.jumsu );  <- X
		int jumsu = html.getJumsu();
		System.out.print( jumsu );  <- O
		System.out.print( html.getJumsu() );  <- O
		
	}
}







