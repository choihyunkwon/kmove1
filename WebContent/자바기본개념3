데이터타입: 프리미티브타입 - byte < short < int < long
                                          float < double
                           char                
            레퍼런스타입 - 클래스로 선언된 타입 - 주소를 참조하는 형태
        
통장 클래스 선언
class BankBook{
	//필드: 성명, 계좌번호, 비밀번호, 잔액
	private String name, accountNo, password;
	private int balance; 
	
	public BankBook(String name, String accountNo){
		this.name = name;
		this.accountNo = accountNo;		
	}
	
	//비밀번호를 변경하는 기능의 메소드
	public void setPassword(String password){
		this.password = password;
	}
	
	//잔액을 변경하는 메소드: 입금하는 기능
	public void setBalance(int balance){
		this.balance += balance;
	}
	
	//잔액을 변경하는 메소드: 출금하는 기능
	public int getOutMoney(int money) throws Exception{
		if(balance < money ) 
			throw new Exception("잔고 부족으로 출금 불가!");
		balance -= money;
		return money;
	}
	
	//setter, getter 메소드선언
	//: 오른마우스 > source > Generate getters and Setters ..
	
	//필드의 데이터값을 리턴하는 메소드: getter메소드
	public String getName(){
		return name;
	}
	public String getAccountNo(){
		return accountNo;
	}
	public int getBalance(){
		return balance;
	} 
	
	
}

class BankBookMain{
	public static void main(String[] a){
		//홍길동씨가 통장을 하나 만든다
		BankBook hong = new BankBook("홍길동", "123-45-6789");
		//통장비밀번호를 입력한다.
		hong.setPassword("0123");
		//10000 원을 은행원에게 건넨다
		hong.setBalance(10000); //잔액:10,000
		
		//CD기로 100000 만원을 입금한다.
		hong.setBalance(100000); //잔액:110,000
	
		//Exception 을 던지는 처리가 된 메소드나 생성자를 호출할때는
		//반드시 try~catch 블럭으로 처리해야 한다.
		try{
			//CD기로 50000 만원을 출금한다.
			int receiveMoney = hong.getOutMoney(50000);//잔액:60,000
			readAccountInfo(hong);
		}catch( Exception e){
		}
		
		//CD기로 100000 만원을 출금한다.
		try{
			int receiveMoney = hong.getOutMoney(100000); //잔고부족
			readAccountInfo(hong);
		}catch( Exception e){
		}
		
		//홍길동씨가 은행원으로부터 받은 통장을 눈으로 확인한다.
		//-> Console 에 출력해본다.
		//System.out.println("성명: " + hong.getName() );
		//System.out.println("계좌번호: " + hong.getAccountNo() );
		//System.out.println("잔액: " + hong.getBalance() );
		readAccountInfo(hong);
		
		//심청씨가 통장을 만든다.
		BankBook sim = new BankBook("심청", "456-78-9876");
		//통장비밀번호를 입력한다.
		sim.setPassword("9876");
		//50000 원을 은행원에게 건넨다
		sim.setBalance(50000);
		
		//심청씨가 은행원으로부터 받은 통장을 눈으로 확인한다.
		//-> Console 에 출력해본다.
		//System.out.println("성명: " + sim.getName() );
		//System.out.println("계좌번호: " + sim.getAccountNo() );
		//System.out.println("잔액: " + sim.getBalance() );
		readAccountInfo(sim);
		
		//전우치씨가 마이너스 통장을 만든다.
		MinusBankBook jeon = new MinusBankBook("전우치", "567-89-1234", 2000000);
		//통장비밀번호를 입력한다.
		jeon.setPassword("4567");
		//50000 원을 은행원에게 건넨다
		jeon.setBalance(50000); //잔액:50000
		//전우치씨가 은행원으로부터 받은 통장을 눈으로 확인한다.
		//-> Console 에 출력해본다.
		readAccountInfo(jeon);
		
		//CD기로 100000 만원을 출금한다.
		try{
			int money = jeon.getOutMoney(100000);
		}catch(Exception e){
		}
		//전우치씨가 은행원으로부터 받은 통장을 눈으로 확인한다.
		//-> Console 에 출력해본다.
		readAccountInfo(jeon); //잔액: -50,000
		
	}
	
	//static 으로 선언된 메소드에서 호출되어지는 메소드는
	//반드시 static으로 선언해야만 한다.
	
	//통장을 눈으로 확인하는 메소드: 성명,계좌번호,잔액을 출력
	static void readAccountInfo(BankBook who){
		//파라미터로 받게 되는 데이터의 타입이 BankBook, MinusBankBook 
		//모두 데이터타입으로 BankBook 타입을 선언할 수 있다
		//-> 다형성(polymorphism)
		//: 상속,구현을 통해 선언한 서브클래스는
		//수퍼클래스, 구현한 인터페이스의 타입으로 선언할 수 있다. 
		 
		System.out.println("성명: " + who.getName() );
		System.out.println("계좌번호: " + who.getAccountNo() );
		System.out.println("잔액: " + who.getBalance() );
	} 
}

상속과 다형성 -----------------------------------------------
class 포유류{
}

class 개과 extends 포유류{
}
class 개 extends 개과{
}
class 늑대 extends 개과{
}

class 고양이과 extends 포유류{
}
class 고양이 extends 고양이과{
}
class 호랑이 extends 고양이과{
}

포유류 a = new 포유류();
개과 b = new 개과();
늑대 c = new 늑대();
고양이 d = new 고양이();
호랑이 e = new 호랑이();

개과 f = new 늑대(); O        	늑대를 개과라고 표현할 수 있다
포유류 g = new 늑대(); O       	늑대를 포유류라고 표현할 수 있다 
고양이과 h = new 호랑이(); O   	호랑이를 고양이과라고 표현할 수 있다
포유류 h = new 호랑이();   O   	호랑이를 포유류라고 표현할 수 있다

늑대 e = new 개과(); X	    	개과를 늑대라고 표현할 수 없다
늑대 e = new 포유류(); X			포유류를 늑대라고 표현할 수 없다
호랑이 e = new 고양이과(); X		고양이과를 호랑이라고 표현할 수 없다
호랑이 e = new 포유류(); X		포유류를 호랑이라고 표현할 수 없다

다형성(polymorphism)
: 상속(extends)이나 구현(implement)을 통해 선언한 서브클래스는
  상속받은 수퍼클래스나 구현한 인터페이스의 타입으로 선언할 수 있는 것 
-------------------------------------------------------------



마이너스 통장도 통장의 일부라 통장의 기본필드, 기본기능을 모두 갖는다
-> 통장을 상속: extends 부모클래스
부모-자식클래스 , super-sub클래스
class MinusBankBook extends BankBook{
	//필드: 성명, 계좌번호, 비밀번호, 잔액, 마이너스한도
	private int minusLimit; 

	public MinusBankBook(String name, String accountNo){
		//this.name = name;
		//this.accountNo = accountNo;
		//서브클래스에서 수퍼클래스의 생성자를 호출한다. - super
		super(name, accountNo); 		
	}
	public MinusBankBook(String name, String accountNo, int minusLimit){
		//this.name = name;
		//this.accountNo = accountNo;
		//생성자내부에서 다른 생성자를 호출한다.-this
		this(name, accountNo);
		this.minusLimit = minusLimit;		
	}
	
	//잔액을 변경하는 메소드: 출금하는 기능
	//수퍼클래스의 메소드 본체{} 내부의 처리를 변경해서
	//메소드를 선언한다. - 메소드 오버라이딩(overriding)
	public int getOutMoney(int money) throws Exception{
		if(balance + minusLimit < money ) 
			throw new Exception("잔고 부족으로 출금 불가!");
		balance -= money;
		return money;
	}
}

메소드 오버라이딩(overriding) 
: 수퍼클래스나 인터페이스를 상속/구현할 때 
상속/구현을 통해 선언되어 있는 수퍼클래스나 인터페이스의 메소드를 재선언하는 것


